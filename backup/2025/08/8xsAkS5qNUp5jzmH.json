{
  "active": false,
  "connections": {
    "Get Meeting Pages from Notion": {
      "main": [
        [
          {
            "node": "Create Toggle block",
            "type": "main",
            "index": 0
          },
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Transcript into Blocks": {
      "main": [
        [
          {
            "node": "Convert Blocks to notion Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Toggle ID with Content": {
      "main": [
        [
          {
            "node": "Append a block",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download file": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Toggle block": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Merge Toggle ID with Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Meeting Pages from Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Split Transcript into Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Convert Blocks to notion Items": {
      "main": [
        [
          {
            "node": "Flatten Block → type & text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk blocks to notion": {
      "main": [
        []
      ]
    },
    "Flatten Block → type & text": {
      "main": [
        [
          {
            "node": "Merge Toggle ID with Content",
            "type": "main",
            "index": 1
          }
        ]
      ]
    }
  },
  "createdAt": "2025-08-19T07:07:38.167Z",
  "id": "8xsAkS5qNUp5jzmH",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Add transcript trigger",
  "nodes": [
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "f22d8083-6d1d-4759-a1c0-c133a4cce8c9",
          "mode": "list",
          "cachedResultName": "DB.Client Meeting Diary",
          "cachedResultUrl": "https://www.notion.so/f22d80836d1d4759a1c0c133a4cce8c9"
        },
        "returnAll": true,
        "filterType": "manual",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "Cancel"
            },
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "No Show"
            },
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "Upcoming Meeting"
            },
            {
              "key": "GDrive Transcript URL|url",
              "condition": "is_not_empty"
            },
            {
              "key": "GDrive Transcript URL|url",
              "condition": "does_not_equal",
              "urlValue": "=Failed to Upload Transcript to Google Drive"
            },
            {
              "key": "Meeting Date|date",
              "condition": "on_or_after",
              "date": "2025-08-01T00:00:00"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        480,
        512
      ],
      "id": "1e7ab268-e209-46c5-909f-72ad6de9c1e0",
      "name": "Get Meeting Pages from Notion",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Read transcript robustly (works if you keep the Set node disabled)\nconst first = $input.first();\nconst markdownContent = String(first?.json?.Content ?? first?.json?.text ?? first?.json?.data ?? '');\n\n// If empty, stop\nif (!markdownContent.trim()) {\n  return [];\n}\n\nconst cleanContent = markdownContent;\n\n// Helpers for table detection\nfunction isTableSeparator(line) {\n  return /^[\\s]*\\|?[\\s]*[-:]+[\\s]*\\|/.test(line);\n}\nfunction isTableRow(line) {\n  const t = line.trim();\n  return t.includes('|') && !t.startsWith('*') && !t.startsWith('-') && !t.startsWith('•');\n}\n\nconst lines = cleanContent.split('\\n');\n\nconst paragraphBlocks = [];\nlet currentBlock = [];\nlet inTable = false;\nlet currentSection = '';\n\nfor (let i = 0; i < lines.length; i++) {\n  const line = lines[i];\n  const trimmed = line.trim();\n\n  // Section heading: supports \"# 1. ...\" or \"1. ...\"\n  if (/^#+\\s+\\d+\\.\\s+/.test(trimmed) || /^\\d+\\.\\s+/.test(trimmed)) {\n    if (currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: inTable ? 'table' : 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    currentSection = trimmed.replace(/^#+\\s+/, '');\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Table lines\n  if (isTableRow(line) || isTableSeparator(line)) {\n    if (!inTable && currentBlock.length > 0 && !isTableRow(currentBlock[currentBlock.length - 1] || '')) {\n      paragraphBlocks.push({\n        type: 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n    }\n    inTable = true;\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Bullets (•, -, *)\n  if (trimmed.startsWith('•') || trimmed.startsWith('-') || trimmed.startsWith('*')) {\n    if (inTable && currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: 'table',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Blank line → paragraph break\n  if (trimmed === '') {\n    if (currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: inTable ? 'table' : 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    continue;\n  }\n\n  // Normal text\n  if (inTable && !isTableRow(line)) {\n    paragraphBlocks.push({\n      type: 'table',\n      section: currentSection,\n      content: currentBlock.join('\\n').trim(),\n    });\n    currentBlock = [];\n    inTable = false;\n  }\n  currentBlock.push(line);\n}\n\n// Flush\nif (currentBlock.length > 70.15) {\n  paragraphBlocks.push({\n    type: inTable ? 'table' : 'paragraph',\n    section: currentSection,\n    content: currentBlock.join('\\n').trim(),\n  });\n}\n\n// Emit one item per block\nreturn paragraphBlocks\n  .filter(b => b.content && b.content.trim() !== '')\n  .map((block, idx) => ({\n    json: {\n      blockNumber: idx + 1,\n      type: block.type,\n      section: block.section,\n      content: block.content,\n      title: block.section || `Block ${idx + 1}`,\n      isHeading: /^#+\\s+\\d+\\.\\s+/.test(block.content.trim()) || /^\\d+\\.\\s+/.test(block.content.trim()),\n    }\n  }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2608,
        608
      ],
      "id": "a85f4588-ee2f-43b2-8df0-feeea0e12417",
      "name": "Split Transcript into Blocks",
      "alwaysOutputData": true,
      "notesInFlow": true,
      "notes": "Divide transcript into chunks for Notion blocks"
    },
    {
      "parameters": {
        "mode": "combineBySql",
        "query": "SELECT\n  input1.toggleID            AS toggleID,\n  input2.block_type          AS \"block type\",\n  input2.text_content        AS \"text content\"\nFROM input2\nCROSS JOIN input1\n",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3408,
        384
      ],
      "id": "af413440-20e8-43fe-b3e7-f31d6a1a3161",
      "name": "Merge Toggle ID with Content",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.property_g_drive_transcript_url }}",
          "mode": "url"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1344,
        608
      ],
      "id": "818ddaca-df9a-483c-8f81-7cbed942910e",
      "name": "Download file",
      "alwaysOutputData": true,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "psUJfPffy3IsMJGV",
          "name": "Google Drive account 4"
        }
      }
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1712,
        608
      ],
      "id": "999fc402-6bac-45f5-8a05-83ef38e8290b",
      "name": "Extract from File",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "resource": "block",
        "blockId": {
          "__rl": true,
          "value": "={{ $json.url }}",
          "mode": "url"
        },
        "blockUi": {
          "blockValues": [
            {
              "type": "toggle",
              "textContent": "=\"Transcript\"- {{ $json.name }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        1488,
        368
      ],
      "id": "883eb050-d6d2-498b-aa69-30f98f0089a7",
      "name": "Create Toggle block",
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "505b2675-318f-4671-abd2-95d5a76ad8f5",
              "name": "toggleID",
              "value": "={{ $json.results.first().id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1920,
        368
      ],
      "id": "0526b545-ea16-47ee-b621-c6cef039e2df",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        112,
        512
      ],
      "id": "0781c197-71ee-4e14-9c25-9b587e4d9e58",
      "name": "Schedule Trigger",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=TASK: Analyze the meeting transcript and create a structured report with EXACTLY 8 sections.\n\nDO NOT CREATE:\n- Slides\n- Presentations  \n- Product descriptions\n- Marketing materials\n- Anything other than the 8-section report below\n\nYOU MUST CREATE ONLY THIS:\nA markdown report with these exact 8 sections in this exact order:\n\nSECTION 1: Write \"# 1. Summary (Minutes of Meeting)\"\nThen write 2-4 sentences about what happened in the meeting.\n\nSECTION 2: Write \"# 2. Action Items → Owner → Due\"\nThen create a markdown table with columns: Task | Owner | Due\nList each action item mentioned in the meeting.\n\nSECTION 3: Write \"# 3. Positive Notes (from client)\"\nList positive things the client said using bullet points (•).\n\nSECTION 4: Write \"# 4. Negative Notes / Risks\"  \nList problems or concerns using bullet points (•).\n\nSECTION 5: Write \"# 5. Overall Client Sentiment\"\nChoose ONE emoji (😀 or 😐 or ☹️) and explain why in one line.\n\nSECTION 6: Write \"# 6. Competitors / Other Vendors Mentioned\"\nWrite \"None mentioned\" OR create a table if any were mentioned.\n\nSECTION 7: Write \"# 7. Client Feedback / Suggestions\"\nList client requests using bullet points (•).\n\nSECTION 8: Write \"# 8. Highlights (if any)\"\nList important facts or statistics using bullet points (•).\n\nIMPORTANT RULES:\n- Start immediately with \"# 1. Summary (Minutes of Meeting)\"\n- Do not write any introduction\n- Do not write any conclusion\n- Extract real names and facts from the transcript\n- Use bullet point symbol • not -\n- Use format YYYY-MM-DD for dates or write TBD\n\nTHE TRANSCRIPT TO ANALYZE:\n{{ $json.data }}\n\nBEGIN YOUR RESPONSE NOW WITH:\n# 1. Summary (Minutes of Meeting)",
        "batching": {
          "batchSize": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2128,
        608
      ],
      "id": "1f411dba-703e-4c94-ba43-e8226b1acca1",
      "name": "Basic LLM Chain",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": "gpt-oss:latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2064,
        816
      ],
      "id": "d8f44501-5f34-4480-97e9-ee5bf0d09bdc",
      "name": "Ollama Model",
      "credentials": {
        "ollamaApi": {
          "id": "dTQFlLdX7jwDMiyh",
          "name": "Local Ollama"
        }
      }
    },
    {
      "parameters": {
        "resource": "block",
        "blockId": {
          "__rl": true,
          "value": "={{ $json.toggleID }}",
          "mode": "id"
        },
        "blockUi": {
          "blockValues": [
            {
              "type": "={{ $json['\\'block type\\''] }}",
              "textContent": "={{ $json['\\'text content\\''] }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        3632,
        384
      ],
      "id": "89019455-d628-4b86-a6e0-c55cd02b1e12",
      "name": "Append a block",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Input: items like { blockNumber, type, section, content, isHeading }\n// Output: one item per Notion block -> { json: { block } }\n\n// ---------- helpers ----------\nfunction toStr(v) { return v == null ? '' : String(v); }\nfunction stripMdStars(s) { return toStr(s).replace(/\\*\\*/g, '').trim(); }\n\nfunction rt(raw) {\n  const text = toStr(raw);\n  const parts = [];\n  const re = /\\*\\*([^*]+)\\*\\*/g;\n  let last = 0, m;\n  while ((m = re.exec(text)) !== null) {\n    if (m.index > last) parts.push({ type: 'text', text: { content: text.slice(last, m.index) } });\n    parts.push({ type: 'text', text: { content: m[1] }, annotations: { bold: true } });\n    last = m.index + m[0].length;\n  }\n  if (last < text.length) parts.push({ type: 'text', text: { content: text.slice(last) } });\n  if (!parts.length) parts.push({ type: 'text', text: { content: text } });\n  return parts;\n}\n\nfunction headingBlock(level, text) {\n  const lvl = Math.min(Math.max(level, 1), 3);\n  const key = `heading_${lvl}`;\n  return { type: key, [key]: { rich_text: rt(text) } };\n}\nfunction makeParagraph(t) {\n  const cleaned = toStr(t).replace(/<br\\s*\\/?>/gi, '\\n');\n  return { type: 'paragraph', paragraph: { rich_text: rt(cleaned) } };\n}\n\nfunction isMdHeading(line) { return /^#{1,3}\\s+/.test(line); }\nfunction isNumbered(line)  { return /^\\d+\\.\\s+/.test(line); }\nfunction isBullet(line)    { return /^(?:•|-|\\*)\\s+/.test(line); }\nfunction isDivider(line)   { return /^-{3,}$/.test(line); }\nfunction isTableish(line)  { return line.includes('|'); }\n\nfunction normSection(s) {\n  return stripMdStars(s).toLowerCase()\n    .replace(/\\s+/g, ' ')\n    .replace(/[^\\w\\s&/-]+/g, '')\n    .trim();\n}\nfunction isAgendaSection(section) {\n  const n = normSection(section || '');\n  return n === 'agenda';\n}\nfunction isKeyDiscussionSection(section) {\n  const n = normSection(section || '');\n  // match variants like \"Key Discussion Points & Decisions\", \"Key Discussions & Decisions\", etc.\n  return /key discussion/.test(n) || /key discussions/.test(n);\n}\nfunction isActionItemsSection(section) {\n  const n = normSection(section || '');\n  return /action items?/.test(n);\n}\n\nfunction parseMdTable(md) {\n  const lines = toStr(md).split('\\n').map(s => s.trim()).filter(Boolean);\n  const rows = lines.filter(l => l.startsWith('|'));\n  if (rows.length < 1) return { headers: [], rows: [] };\n\n  const splitRow = r => r.replace(/^\\|/, '').replace(/\\|$/, '').split('|').map(c => stripMdStars(c.trim()));\n  let cells = rows.map(splitRow);\n\n  // detect header separator on second row\n  const hasSep = rows[1] && /^:?-{3,}:?(?:\\s*\\|\\s*:?-{3,}:?)*$/.test(rows[1].replace(/\\s+/g,''));\n\n  const headers = hasSep ? cells[0] : [];\n  const start = hasSep ? 2 : 1;\n  const dataRows = cells.slice(start);\n\n  // normalize col counts\n  const width = Math.max(headers.length, ...dataRows.map(r => r.length), 0);\n  const pad = arr => {\n    const out = arr.slice(0, width);\n    while (out.length < width) out.push('');\n    return out;\n  };\n  const normHeaders = pad(headers);\n  const normRows = dataRows.map(pad);\n\n  return { headers: normHeaders, rows: normRows };\n}\n\nfunction findColIdx(headers, candidates) {\n  if (!headers || !headers.length) return -1;\n  const H = headers.map(h => h.toLowerCase().trim());\n  for (const name of candidates) {\n    const idx = H.indexOf(name);\n    if (idx !== -1) return idx;\n  }\n  return -1;\n}\n\n// ---------- converters for special sections ----------\nfunction convertKeyDiscussionTableToParagraphBlocks(md) {\n  const { headers, rows } = parseMdTable(md);\n  const blocks = [];\n\n  // flexible header mapping\n  const idxTopic    = findColIdx(headers, ['topic', 'subject', 'title']) !== -1 ? findColIdx(headers, ['topic', 'subject', 'title']) : (headers.length ? 1 : 1);\n  const idxSummary  = findColIdx(headers, ['summary', 'notes', 'description']);\n  const idxDecision = findColIdx(headers, ['decision', 'decision / insight', 'decision/insight', 'insight']);\n  const idxAction   = findColIdx(headers, ['action', 'next steps', 'next step']);\n\n  for (const r of rows) {\n    const topic    = stripMdStars(r[idxTopic]    ?? '');\n    const summary  = stripMdStars(idxSummary  >= 0 ? r[idxSummary]  : '');\n    const decision = stripMdStars(idxDecision >= 0 ? r[idxDecision] : '');\n    const action   = stripMdStars(idxAction   >= 0 ? r[idxAction]   : '');\n\n    if (topic)    blocks.push(makeParagraph(`Topic: ${topic}`));\n    if (summary)  blocks.push(makeParagraph(`Summary: ${summary}`));\n    if (decision) blocks.push(makeParagraph(`Decision: ${decision}`));\n    blocks.push(makeParagraph(`Action: ${action || 'NA'}`));\n  }\n  return blocks;\n}\n\nfunction convertActionItemsTableToParagraphBlocks(md) {\n  const { headers, rows } = parseMdTable(md);\n  const blocks = [];\n\n  const idxOwner    = findColIdx(headers, ['owner', 'responsible', 'assignee']);\n  const idxAction   = findColIdx(headers, ['action', 'task']);\n  const idxDeadline = findColIdx(headers, ['deadline', 'due', 'due date', 'date']);\n\n  for (const r of rows) {\n    const owner    = stripMdStars(idxOwner    >= 0 ? r[idxOwner]    : '');\n    const action   = stripMdStars(idxAction   >= 0 ? r[idxAction]   : '');\n    const deadline = stripMdStars(idxDeadline >= 0 ? r[idxDeadline] : '');\n    if (owner)    blocks.push(makeParagraph(`Owner: ${owner}`));\n    if (action)   blocks.push(makeParagraph(`Action: ${action}`));\n    if (deadline) blocks.push(makeParagraph(`Deadline: ${deadline}`));\n  }\n  return blocks;\n}\n\n// ---------- main ----------\nconst out = [];\n\nfor (const item of $input.all()) {\n  const raw = toStr(item?.json?.content).trim();\n  const kind = toStr(item?.json?.type);\n  const section = toStr(item?.json?.section);\n  if (!raw) continue;\n\n  // Drop dividers\n  if (isDivider(raw)) continue;\n\n  // Headings (#, ##, ###) -> keep as heading_1..3\n  if (isMdHeading(raw)) {\n    const hashes = raw.match(/^#{1,3}/)[0];\n    const level  = hashes.length;\n    const title  = raw.replace(/^#{1,3}\\s+/, '').trim();\n    const label  = stripMdStars(title);\n\n    if (/^agenda$/i.test(label)) {\n      out.push({ json: { block: headingBlock(2, 'Agenda') } });\n    } else {\n      out.push({ json: { block: headingBlock(level, title) } });\n    }\n    continue;\n  }\n\n  // Special plain \"Agenda\" line (e.g., \"**Agenda**\")\n  if (/^agenda$/i.test(stripMdStars(raw))) {\n    out.push({ json: { block: headingBlock(2, 'Agenda') } });\n    continue;\n  }\n\n  // ---------- Section-specific handling ----------\n  const inAgenda       = isAgendaSection(section);\n  const inKeyDiscussion = isKeyDiscussionSection(section);\n  const inActionItems   = isActionItemsSection(section);\n\n  // Tables\n  if (kind === 'table' || (isTableish(raw) && /\\|[-:]+\\|/.test(raw))) {\n    if (inKeyDiscussion) {\n      const blocks = convertKeyDiscussionTableToParagraphBlocks(raw);\n      for (const b of blocks) out.push({ json: { block: b } });\n      continue;\n    }\n    if (inActionItems) {\n      const blocks = convertActionItemsTableToParagraphBlocks(raw);\n      for (const b of blocks) out.push({ json: { block: b } });\n      continue;\n    }\n    // Not in special sections -> flatten table to paragraphs (no table blocks)\n    const lines = raw.split('\\n').map(s => s.trim()).filter(Boolean)\n      .filter(r => !/^(\\|?\\s*:?-{3,}:?\\s*\\|)+\\s*$/.test(r))\n      .map(r => r.replace(/^\\|/, '').replace(/\\|$/, '').split('|').map(c => c.trim()).join(' | '));\n    for (const line of lines) out.push({ json: { block: makeParagraph(line) } });\n    continue;\n  }\n\n  // Bullets / Numbered:\n  if (isBullet(raw) || isNumbered(raw)) {\n    const text = isBullet(raw) ? raw.replace(/^(?:•|-|\\*)\\s+/, '') : raw.replace(/^\\d+\\.\\s+/, '');\n    // Inside special sections -> force paragraph\n    if (inAgenda || inKeyDiscussion || inActionItems) {\n      out.push({ json: { block: makeParagraph(text) } });\n    } else {\n      // Outside specials -> keep bullets\n      out.push({ json: { block: { type: 'bulleted_list_item', bulleted_list_item: { rich_text: rt(text) } } } });\n    }\n    continue;\n  }\n\n  // Default plain paragraph (also applies to text inside special sections)\n  out.push({ json: { block: makeParagraph(raw) } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        608
      ],
      "id": "035b4c1c-85c0-4cd9-90a7-9d12eb2e1a66",
      "name": "Convert Blocks to notion Items",
      "alwaysOutputData": true,
      "notesInFlow": true,
      "notes": "Convert the chunks into individual items for appending"
    },
    {
      "parameters": {
        "jsCode": "// Input items should look like: { json: { toggleID, block } }  (from the Merge node)\n// Output: items like { json: { toggleID, children: [ up to 100 notion blocks ] } }\n\nfunction isObj(v){ return v && typeof v === 'object' && !Array.isArray(v); }\n\nconst items = Array.isArray($input.all()) ? $input.all() : [];\nif (!items.length) {\n  // nothing to send; keep silent rather than throw\n  return [];\n}\n\n// Group blocks by toggleID (supports multiple toggles in one run)\nconst groups = new Map();\n\nfor (const it of items) {\n  const id = it?.json?.toggleID;\n  const block = it?.json?.block;\n\n  // Skip anything malformed\n  if (!id) continue;\n  if (!isObj(block)) continue;\n\n  if (!groups.has(id)) groups.set(id, []);\n  groups.get(id).push(block);\n}\n\n// Build chunked payloads (≤100 children per Notion append call)\nconst MAX = 100;\nconst out = [];\n\nfor (const [toggleID, blocks] of groups.entries()) {\n  for (let i = 70.15; i < blocks.length; i += MAX) {\n    const slice = blocks.slice(i, i + MAX);\n    if (slice.length) {\n      out.push({ json: { toggleID, children: slice } });\n    }\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3632,
        1152
      ],
      "id": "27033858-6a85-4848-8029-34050050be47",
      "name": "Chunk blocks to notion",
      "alwaysOutputData": true,
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Input item example: { json: { block: { type, <type>:{ rich_text:[...] } }, ... } }\n// Output: { json: { block, block_type, text_content } } (preserving block)\n\nfunction toStr(v){ return v == null ? '' : String(v); }\n\nfunction extractTextFromBlock(block) {\n  if (!block || typeof block !== 'object') return '';\n  const t = block.type;\n  if (!t || !block[t]) return '';\n\n  // Rich-text types\n  const rt = block[t].rich_text;\n  if (Array.isArray(rt)) {\n    // join all segments’ text\n    return rt.map(seg => toStr(seg?.text?.content)).join('');\n  }\n\n  // Simple types\n  if (t === 'divider') return '---';\n  // For tables we’ll keep it empty (they don’t have rich_text at block level)\n  return '';\n}\n\nconst out = [];\nfor (const it of $input.all()) {\n  const j = it.json || {};\n  const block = j.block;\n  const block_type = block?.type || '';\n  const text_content = extractTextFromBlock(block);\n  out.push({ json: { ...j, block, block_type, text_content } });\n}\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3088,
        608
      ],
      "id": "1ca8901a-b704-4378-9608-4426a7b2be3c",
      "name": "Flatten Block → type & text"
    }
  ],
  "pinData": {},
  "repo_name": "n8n-env",
  "repo_owner": "munishgandhi",
  "repo_path": "backup/",
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-08-22T07:29:04.000Z",
  "versionId": "0a88e7b3-0c62-41fa-b005-d3ecc501c3a6"
}