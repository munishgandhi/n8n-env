{
  "active": false,
  "connections": {
    "Get Meeting Pages from Notion": {
      "main": [
        [
          {
            "node": "Create Toggle block",
            "type": "main",
            "index": 0
          },
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Transcript into Blocks": {
      "main": [
        [
          {
            "node": "Convert Blocks to notion Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Toggle ID with Content": {
      "main": [
        [
          {
            "node": "Chunk blocks to notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download file": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Toggle block": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Merge Toggle ID with Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get Meeting Pages from Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Split Transcript into Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Convert Blocks to notion Items": {
      "main": [
        [
          {
            "node": "Merge Toggle ID with Content",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Chunk blocks to notion": {
      "main": [
        [
          {
            "node": "Append a block",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-08-19T07:07:38.167Z",
  "id": "8xsAkS5qNUp5jzmH",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Add transcript trigger",
  "nodes": [
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "f22d8083-6d1d-4759-a1c0-c133a4cce8c9",
          "mode": "list",
          "cachedResultName": "DB.Client Meeting Diary",
          "cachedResultUrl": "https://www.notion.so/f22d80836d1d4759a1c0c133a4cce8c9"
        },
        "limit": 1,
        "filterType": "manual",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "Cancel"
            },
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "No Show"
            },
            {
              "key": "Status|status",
              "condition": "does_not_equal",
              "statusValue": "Upcoming Meeting"
            },
            {
              "key": "Meeting Date|date",
              "condition": "after",
              "date": "2025-08-14T00:00:00"
            },
            {
              "key": "GDrive Transcript URL|url",
              "condition": "is_not_empty"
            },
            {
              "key": "GDrive Transcript URL|url",
              "condition": "does_not_equal",
              "urlValue": "=Failed to Upload Transcript to Google Drive"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        480,
        512
      ],
      "id": "1e7ab268-e209-46c5-909f-72ad6de9c1e0",
      "name": "Get Meeting Pages from Notion",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Read transcript robustly (works if you keep the Set node disabled)\nconst first = $input.first();\nconst markdownContent = String(first?.json?.Content ?? first?.json?.text ?? first?.json?.data ?? '');\n\n// If empty, stop\nif (!markdownContent.trim()) {\n  return [];\n}\n\nconst cleanContent = markdownContent;\n\n// Helpers for table detection\nfunction isTableSeparator(line) {\n  return /^[\\s]*\\|?[\\s]*[-:]+[\\s]*\\|/.test(line);\n}\nfunction isTableRow(line) {\n  const t = line.trim();\n  return t.includes('|') && !t.startsWith('*') && !t.startsWith('-') && !t.startsWith('•');\n}\n\nconst lines = cleanContent.split('\\n');\n\nconst paragraphBlocks = [];\nlet currentBlock = [];\nlet inTable = false;\nlet currentSection = '';\n\nfor (let i = 0; i < lines.length; i++) {\n  const line = lines[i];\n  const trimmed = line.trim();\n\n  // Section heading: supports \"# 1. ...\" or \"1. ...\"\n  if (/^#+\\s+\\d+\\.\\s+/.test(trimmed) || /^\\d+\\.\\s+/.test(trimmed)) {\n    if (currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: inTable ? 'table' : 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    currentSection = trimmed.replace(/^#+\\s+/, '');\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Table lines\n  if (isTableRow(line) || isTableSeparator(line)) {\n    if (!inTable && currentBlock.length > 0 && !isTableRow(currentBlock[currentBlock.length - 1] || '')) {\n      paragraphBlocks.push({\n        type: 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n    }\n    inTable = true;\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Bullets (•, -, *)\n  if (trimmed.startsWith('•') || trimmed.startsWith('-') || trimmed.startsWith('*')) {\n    if (inTable && currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: 'table',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    currentBlock.push(line);\n    continue;\n  }\n\n  // Blank line → paragraph break\n  if (trimmed === '') {\n    if (currentBlock.length > 0) {\n      paragraphBlocks.push({\n        type: inTable ? 'table' : 'paragraph',\n        section: currentSection,\n        content: currentBlock.join('\\n').trim(),\n      });\n      currentBlock = [];\n      inTable = false;\n    }\n    continue;\n  }\n\n  // Normal text\n  if (inTable && !isTableRow(line)) {\n    paragraphBlocks.push({\n      type: 'table',\n      section: currentSection,\n      content: currentBlock.join('\\n').trim(),\n    });\n    currentBlock = [];\n    inTable = false;\n  }\n  currentBlock.push(line);\n}\n\n// Flush\nif (currentBlock.length > 70.15) {\n  paragraphBlocks.push({\n    type: inTable ? 'table' : 'paragraph',\n    section: currentSection,\n    content: currentBlock.join('\\n').trim(),\n  });\n}\n\n// Emit one item per block\nreturn paragraphBlocks\n  .filter(b => b.content && b.content.trim() !== '')\n  .map((block, idx) => ({\n    json: {\n      blockNumber: idx + 1,\n      type: block.type,\n      section: block.section,\n      content: block.content,\n      title: block.section || `Block ${idx + 1}`,\n      isHeading: /^#+\\s+\\d+\\.\\s+/.test(block.content.trim()) || /^\\d+\\.\\s+/.test(block.content.trim()),\n    }\n  }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2608,
        608
      ],
      "id": "a85f4588-ee2f-43b2-8df0-feeea0e12417",
      "name": "Split Transcript into Blocks",
      "alwaysOutputData": true,
      "notesInFlow": true,
      "notes": "Divide transcript into chunks for Notion blocks"
    },
    {
      "parameters": {
        "mode": "combineBySql",
        "query": "SELECT\n  input1.toggleID            AS toggleID,\n  input2.block_type          AS \"block type\",\n  input2.text_content        AS \"text content\"\nFROM input2\nCROSS JOIN input1\n",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3200,
        384
      ],
      "id": "af413440-20e8-43fe-b3e7-f31d6a1a3161",
      "name": "Merge Toggle ID with Content",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.property_g_drive_transcript_url }}",
          "mode": "url"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1344,
        608
      ],
      "id": "818ddaca-df9a-483c-8f81-7cbed942910e",
      "name": "Download file",
      "alwaysOutputData": true,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "psUJfPffy3IsMJGV",
          "name": "Google Drive account 4"
        }
      }
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        1712,
        608
      ],
      "id": "999fc402-6bac-45f5-8a05-83ef38e8290b",
      "name": "Extract from File",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "resource": "block",
        "blockId": {
          "__rl": true,
          "value": "={{ $json.url }}",
          "mode": "url"
        },
        "blockUi": {
          "blockValues": [
            {
              "type": "toggle",
              "textContent": "=\"Transcript\"- {{ $json.name }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        1488,
        368
      ],
      "id": "883eb050-d6d2-498b-aa69-30f98f0089a7",
      "name": "Create Toggle block",
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "505b2675-318f-4671-abd2-95d5a76ad8f5",
              "name": "toggleID",
              "value": "={{ $json.results.first().id }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1920,
        368
      ],
      "id": "0526b545-ea16-47ee-b621-c6cef039e2df",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        112,
        512
      ],
      "id": "0781c197-71ee-4e14-9c25-9b587e4d9e58",
      "name": "Schedule Trigger",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=TASK: Analyze the meeting transcript and create a structured report with EXACTLY 8 sections.\n\nDO NOT CREATE:\n- Slides\n- Presentations  \n- Product descriptions\n- Marketing materials\n- Anything other than the 8-section report below\n\nYOU MUST CREATE ONLY THIS:\nA markdown report with these exact 8 sections in this exact order:\n\nSECTION 1: Write \"# 1. Summary (Minutes of Meeting)\"\nThen write 2-4 sentences about what happened in the meeting.\n\nSECTION 2: Write \"# 2. Action Items → Owner → Due\"\nThen create a markdown table with columns: Task | Owner | Due\nList each action item mentioned in the meeting.\n\nSECTION 3: Write \"# 3. Positive Notes (from client)\"\nList positive things the client said using bullet points (•).\n\nSECTION 4: Write \"# 4. Negative Notes / Risks\"  \nList problems or concerns using bullet points (•).\n\nSECTION 5: Write \"# 5. Overall Client Sentiment\"\nChoose ONE emoji (😀 or 😐 or ☹️) and explain why in one line.\n\nSECTION 6: Write \"# 6. Competitors / Other Vendors Mentioned\"\nWrite \"None mentioned\" OR create a table if any were mentioned.\n\nSECTION 7: Write \"# 7. Client Feedback / Suggestions\"\nList client requests using bullet points (•).\n\nSECTION 8: Write \"# 8. Highlights (if any)\"\nList important facts or statistics using bullet points (•).\n\nIMPORTANT RULES:\n- Start immediately with \"# 1. Summary (Minutes of Meeting)\"\n- Do not write any introduction\n- Do not write any conclusion\n- Extract real names and facts from the transcript\n- Use bullet point symbol • not -\n- Use format YYYY-MM-DD for dates or write TBD\n\nTHE TRANSCRIPT TO ANALYZE:\n{{ $json.data }}\n\nBEGIN YOUR RESPONSE NOW WITH:\n# 1. Summary (Minutes of Meeting)",
        "batching": {
          "batchSize": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2128,
        608
      ],
      "id": "1f411dba-703e-4c94-ba43-e8226b1acca1",
      "name": "Basic LLM Chain",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "model": "gpt-oss:latest",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        2064,
        816
      ],
      "id": "d8f44501-5f34-4480-97e9-ee5bf0d09bdc",
      "name": "Ollama Model",
      "credentials": {
        "ollamaApi": {
          "id": "dTQFlLdX7jwDMiyh",
          "name": "Local Ollama"
        }
      }
    },
    {
      "parameters": {
        "resource": "block",
        "blockId": {
          "__rl": true,
          "value": "={{ $json.toggleID }}",
          "mode": "id"
        }
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        3616,
        384
      ],
      "id": "89019455-d628-4b86-a6e0-c55cd02b1e12",
      "name": "Append a block",
      "alwaysOutputData": true,
      "credentials": {
        "notionApi": {
          "id": "1irJTXhoFNvETAJ1",
          "name": "Notion account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Input: items like { blockNumber, type, section, content, isHeading }\n// Output: one item per Notion block -> { json: { block } }\n\n// --- helpers (SAFE) ---\nfunction toStr(v) { return v == null ? '' : String(v); }\n\nfunction rt(raw) {\n  const text = toStr(raw);                    // <— guard\n  const parts = [];\n  const re = /\\*\\*([^*]+)\\*\\*/g;\n  let last = 0, m;\n  while ((m = re.exec(text)) !== null) {\n    if (m.index > last) parts.push({ type: 'text', text: { content: text.slice(last, m.index) } });\n    parts.push({ type: 'text', text: { content: m[1] }, annotations: { bold: true } });\n    last = m.index + m[0].length;\n  }\n  if (last < text.length) parts.push({ type: 'text', text: { content: text.slice(last) } });\n  if (!parts.length) parts.push({ type: 'text', text: { content: text } });\n  return parts;\n}\n\nfunction makeHeading(t) {\n  const cleaned = toStr(t)\n    .replace(/^#{1,3}\\s+/, '')\n    .replace(/^\\d+\\.\\s+/, '')\n    .trim();\n  return { type: 'heading_2', heading_2: { rich_text: rt(cleaned) } };\n}\n\nfunction makeParagraph(t) {\n  const cleaned = toStr(t).replace(/<br\\s*\\/?>/gi, '\\n');\n  return { type: 'paragraph', paragraph: { rich_text: rt(cleaned) } };\n}\n\nfunction makeDivider() {\n  return { type: 'divider', divider: {} };\n}\n\nfunction makeBullets(blockText) {\n  const blocks = [];\n  const lines = toStr(blockText).split('\\n');\n  for (const raw of lines) {\n    const line = toStr(raw).trim();\n    if (!line) continue;\n    const m = /^(•|-|\\*)\\s*(.*)$/.exec(line);\n    if (m) blocks.push({ type: 'bulleted_list_item', bulleted_list_item: { rich_text: rt(m[2]) } });\n    else   blocks.push(makeParagraph(line));\n  }\n  return blocks;\n}\n\nfunction parseMdTable(md) {\n  const rowLines = toStr(md).split('\\n')\n    .map(l => toStr(l).trim())\n    .filter(Boolean)\n    .filter(l => l.startsWith('|'));\n  if (rowLines.length < 2) return null;\n\n  const splitRow = r => r.replace(/^\\|/, '').replace(/\\|$/, '').split('|').map(c => toStr(c).trim());\n  const cellRows = rowLines.map(splitRow);\n\n  const hasSep = /^:?-{3,}:?(?:\\s*\\|\\s*:?-{3,}:?)*$/.test(toStr(rowLines[1]).replace(/\\s+/g,''));\n  const width = Math.max(...cellRows.map(r => r.length));\n\n  const norm = r => {\n    const out = r.slice(0, width);\n    while (out.length < width) out.push('');\n    return out;\n  };\n\n  const children = [];\n  for (const r of cellRows) {\n    const cells = norm(r).map(c => [{ type: 'text', text: { content: toStr(c).replace(/<br\\s*\\/?>/gi, ' • ') } }]);\n    children.push({ object: 'block', type: 'table_row', table_row: { cells } });\n  }\n\n  return { type: 'table', table: { table_width: width, has_column_header: hasSep, has_row_header: false }, children };\n}\n\n// --- main ---\nconst out = [];\nfor (const item of $input.all()) {\n  const c = toStr(item?.json?.content).trim();\n  const kind = toStr(item?.json?.type);\n  const isHeading = !!item?.json?.isHeading || /^#{1,3}\\s+/.test(c) || /^\\d+\\.\\s+/.test(c);\n\n  if (!c) continue;\n\n  // Divider lines like '---'\n  if (/^-{3,}$/.test(c)) { out.push({ json: { block: makeDivider() } }); continue; }\n\n  // Tables\n  if (kind === 'table' || (/\\|/.test(c) && /\\|[-:]+\\|/.test(c))) {\n    const tbl = parseMdTable(c);\n    out.push({ json: { block: tbl ?? makeParagraph(c) } });\n    continue;\n  }\n\n  // Headings\n  if (isHeading) { out.push({ json: { block: makeHeading(c) } }); continue; }\n\n  // Bulleted lines\n  if (/^\\s*(?:•|-|\\*)\\s+/m.test(c)) {\n    for (const b of makeBullets(c)) out.push({ json: { block: b } });\n    continue;\n  }\n\n  // Default: paragraph\n  out.push({ json: { block: makeParagraph(c) } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2880,
        608
      ],
      "id": "035b4c1c-85c0-4cd9-90a7-9d12eb2e1a66",
      "name": "Convert Blocks to notion Items",
      "alwaysOutputData": true,
      "notesInFlow": true,
      "notes": "Convert the chunks into individual items for appending"
    },
    {
      "parameters": {
        "jsCode": "// Input items should look like: { json: { toggleID, block } }  (from the Merge node)\n// Output: items like { json: { toggleID, children: [ up to 100 notion blocks ] } }\n\nfunction isObj(v){ return v && typeof v === 'object' && !Array.isArray(v); }\n\nconst items = Array.isArray($input.all()) ? $input.all() : [];\nif (!items.length) {\n  // nothing to send; keep silent rather than throw\n  return [];\n}\n\n// Group blocks by toggleID (supports multiple toggles in one run)\nconst groups = new Map();\n\nfor (const it of items) {\n  const id = it?.json?.toggleID;\n  const block = it?.json?.block;\n\n  // Skip anything malformed\n  if (!id) continue;\n  if (!isObj(block)) continue;\n\n  if (!groups.has(id)) groups.set(id, []);\n  groups.get(id).push(block);\n}\n\n// Build chunked payloads (≤100 children per Notion append call)\nconst MAX = 100;\nconst out = [];\n\nfor (const [toggleID, blocks] of groups.entries()) {\n  for (let i = 70.15; i < blocks.length; i += MAX) {\n    const slice = blocks.slice(i, i + MAX);\n    if (slice.length) {\n      out.push({ json: { toggleID, children: slice } });\n    }\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3408,
        384
      ],
      "id": "27033858-6a85-4848-8029-34050050be47",
      "name": "Chunk blocks to notion",
      "alwaysOutputData": true
    }
  ],
  "pinData": {},
  "repo_name": "n8n-env",
  "repo_owner": "munishgandhi",
  "repo_path": "backup/",
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-08-22T05:35:16.000Z",
  "versionId": "3cfdd6ac-d253-483e-a526-5850a1550729"
}